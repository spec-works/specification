#!/usr/bin/env pwsh
<#
.SYNOPSIS
    Generates xRegistry static catalog from SpecWorks parts.

.DESCRIPTION
    This script scans all SpecWorks component repositories, reads their specs.json
    files, and generates a complete xRegistry 0.5 compliant static catalog structure.
    
    The output is designed to be hosted on GitHub Pages at:
    https://spec-works.github.io/registry/

.PARAMETER SourceRoot
    Root directory containing all part repositories (default: parent of specification repo)

.PARAMETER OutputPath
    Directory where registry files will be generated (default: ../../spec-works.github.io/registry)

.PARAMETER RegistryUrl
    Base URL for the deployed registry (default: https://spec-works.github.io/registry)

.EXAMPLE
    .\generate-registry.ps1
    
.EXAMPLE
    .\generate-registry.ps1 -SourceRoot C:\src\github\spec-works -OutputPath C:\output\registry

.NOTES
    Generated by: GitHub Copilot CLI
    Part of: SpecWorks Factory tooling
    Specification: xRegistry 0.5 (https://github.com/xregistry/spec)
#>

[CmdletBinding()]
param(
    [Parameter()]
    [string]$SourceRoot = "",
    
    [Parameter()]
    [string]$OutputPath = "",
    
    [Parameter()]
    [string]$RegistryUrl = "https://spec-works.github.io/registry"
)

# Set defaults if not provided
if ([string]::IsNullOrEmpty($SourceRoot)) {
    $SourceRoot = (Resolve-Path "$PSScriptRoot\..\..").Path
}
if ([string]::IsNullOrEmpty($OutputPath)) {
    $OutputPath = Join-Path $SourceRoot "spec-works.github.io\registry"
}

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

Write-Host "üè≠ SpecWorks xRegistry Generator" -ForegroundColor Cyan
Write-Host "=================================" -ForegroundColor Cyan
Write-Host ""
Write-Host "Source Root:  $SourceRoot"
Write-Host "Output Path:  $OutputPath"
Write-Host "Registry URL: $RegistryUrl"
Write-Host ""

# Part repositories to scan (exclude infrastructure repos)
$excludedDirs = @('.claude', '.github', 'spec-works.github.io', 'specification')
$partDirs = Get-ChildItem -Path $SourceRoot -Directory | 
    Where-Object { $excludedDirs -notcontains $_.Name } |
    Where-Object { Test-Path (Join-Path $_.FullName "specs.json") }

Write-Host "üì¶ Found $($partDirs.Count) parts:" -ForegroundColor Green
$partDirs | ForEach-Object { Write-Host "   - $($_.Name)" }
Write-Host ""

# Ensure output directory exists
New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
New-Item -ItemType Directory -Path "$OutputPath\parts" -Force | Out-Null

# Function to read and parse specs.json
function Get-PartMetadata {
    param([string]$PartPath)
    
    $specsFile = Join-Path $PartPath "specs.json"
    if (-not (Test-Path $specsFile)) {
        return $null
    }
    
    $specs = Get-Content $specsFile -Raw | ConvertFrom-Json
    
    # Extract metadata from linkset
    $specLink = $specs.linkset | Where-Object { $_.rel -eq "describedby" } | Select-Object -First 1
    
    # Construct repo URL from part name
    $partName = Split-Path $PartPath -Leaf
    $repoUrl = "https://github.com/spec-works/$partName"
    
    # Try to get description from README
    $readmePath = Join-Path $PartPath "README.md"
    $description = "Software component"
    if (Test-Path $readmePath) {
        $readme = Get-Content $readmePath -Raw
        # Try to extract first paragraph after title
        if ($readme -match '(?m)^#[^#].*?\r?\n\r?\n(.+?)(\r?\n\r?\n|$)') {
            $description = $matches[1].Trim()
            # Remove markdown formatting
            $description = $description -replace '\[([^\]]+)\]\([^\)]+\)', '$1'
            $description = $description -replace '[*_`]', ''
            # Truncate to reasonable length
            if ($description.Length -gt 200) {
                $description = $description.Substring(0, 197) + "..."
            }
        }
    }
    
    return @{
        Id = (Split-Path $PartPath -Leaf).ToLower()
        Name = (Split-Path $PartPath -Leaf)
        Description = $description
        SpecsJson = $specs
        RepoUrl = $repoUrl
        SpecificationUrl = $specLink.href
    }
}

# Collect all part metadata
Write-Host "üìã Collecting part metadata..." -ForegroundColor Yellow
$parts = @{}
foreach ($dir in $partDirs) {
    $metadata = Get-PartMetadata -PartPath $dir.FullName
    if ($metadata) {
        $parts[$metadata.Id] = $metadata
        Write-Host "   ‚úì $($metadata.Name)" -ForegroundColor Green
    }
}
Write-Host ""

# Generate root xRegistry document
Write-Host "üî® Generating xRegistry root document..." -ForegroundColor Yellow

$partsArray = @()
foreach ($partId in ($parts.Keys | Sort-Object)) {
    $part = $parts[$partId]
    
    # Create part directory
    $partDir = Join-Path $OutputPath "parts\$partId"
    $versionDir = Join-Path $partDir "versions\1.0.0"
    New-Item -ItemType Directory -Path $versionDir -Force | Out-Null
    
    # Copy specs.json as part.json
    $part.SpecsJson | ConvertTo-Json -Depth 10 | Set-Content -Path (Join-Path $versionDir "part.json")
    
    # Create version metadata
    $versionMeta = @{
        id = "1.0.0"
        epoch = 1
        self = "$RegistryUrl/parts/$partId/versions/1.0.0"
        parturl = "$RegistryUrl/parts/$partId/versions/1.0.0/part.json"
        contenttype = "application/linkset+json"
    }
    
    # Create part metadata
    $partMeta = [ordered]@{
        id = $partId
        name = "$($part.Name) Component"
        description = $part.Description
        epoch = 1
        self = "$RegistryUrl/parts/$partId"
        defaultversionid = "1.0.0"
        defaultversionurl = "$RegistryUrl/parts/$partId/versions/1.0.0"
        versionsurl = "$RegistryUrl/parts/$partId/versions"
        versionscount = 1
        versions = @{
            "1.0.0" = $versionMeta
        }
    }
    
    # Save part index
    $partMeta | ConvertTo-Json -Depth 10 | Set-Content -Path (Join-Path $partDir "index.json")
    
    $partsArray += $partMeta
    Write-Host "   ‚úì $partId" -ForegroundColor Green
}

# Create parts collection
$partsCollection = [ordered]@{}
foreach ($part in $partsArray) {
    $partsCollection[$part.id] = $part
}

# Generate root registry document
$registry = [ordered]@{
    specversion = "0.5"
    id = "specworks-factory"
    name = "SpecWorks Factory Inventory"
    description = "Catalog of specification-based software components"
    epoch = 1
    self = "$RegistryUrl/"
    model = @{
        schemas = @("xRegistry-json")
        groups = @{
            "*" = @{
                plural = "parts"
                singular = "part"
                resources = @{
                    "*" = @{
                        plural = "versions"
                        singular = "version"
                        versions = 1
                    }
                }
            }
        }
    }
    partsurl = "$RegistryUrl/parts"
    partscount = $partsArray.Count
    parts = $partsCollection
}

# Save root document
$registry | ConvertTo-Json -Depth 20 | Set-Content -Path (Join-Path $OutputPath "index.json")
Write-Host "   ‚úì Root document saved" -ForegroundColor Green
Write-Host ""

# Generate parts index
Write-Host "üìë Generating parts index..." -ForegroundColor Yellow
$partsIndex = [ordered]@{
    count = $partsArray.Count
    parts = $partsCollection
}
$partsIndex | ConvertTo-Json -Depth 20 | Set-Content -Path (Join-Path $OutputPath "parts\index.json")
Write-Host "   ‚úì Parts index saved" -ForegroundColor Green
Write-Host ""

# Summary
Write-Host "‚úÖ Registry generation complete!" -ForegroundColor Green
Write-Host ""
Write-Host "üìä Summary:" -ForegroundColor Cyan
Write-Host "   Parts registered: $($partsArray.Count)"
Write-Host "   Registry URL:     $RegistryUrl/"
Write-Host "   Output location:  $OutputPath"
Write-Host ""
Write-Host "üîó Access URLs:" -ForegroundColor Cyan
Write-Host "   Registry root: $RegistryUrl/"
Write-Host "   Parts index:   $RegistryUrl/parts/"
foreach ($partId in ($parts.Keys | Sort-Object)) {
    Write-Host "   $($parts[$partId].Name): $RegistryUrl/parts/$partId/"
}
Write-Host ""
Write-Host "Next steps:" -ForegroundColor Yellow
Write-Host "1. Review generated files in: $OutputPath"
Write-Host "2. Commit and push to deploy to GitHub Pages"
Write-Host "3. Test registry at: $RegistryUrl/"
Write-Host ""
